
# DESTDIR will be emtpy if not set in the app .pro file; make sure it has a value
isEmpty(DESTDIR) : DESTDIR = $$OUT_PWD

# Copies the given files to the destination directory
defineTest(copyToDestDir) {
    files = $$1

    for(FILE, files) {
        # Replace slashes in paths with backslashes for Windows
        win32:FILE ~= s,/,\\,g
        win32:DDIR ~= s,/,\\,g

        QMAKE_POST_LINK += $$QMAKE_COPY $$quote($$FILE) $$quote($$DESTDIR) $$escape_expand(\\n\\t)
    }
    export(QMAKE_POST_LINK)
}

# Create js and wasm files for applications
contains(TEMPLATE, .*app) {
    TARGET_BASE = $${TARGET}
    TARGET_HTML = $${TARGET}.html
    TARGET_JS = $${TARGET}.js

    # Make the emscripten compiler generate a js file
    TARGET = $$TARGET_JS

    QMAKE_INCDIR += $$(HOME)/.emscripten_ports/openssl/include

    CONFIG += static
        js_file.files = TARGET_JS
        js_file.path += $$target.path
        isEmpty(js_file.path)
          js_file.path += ./
        INSTALLS += js_file

    !contains(CONFIG,config_test):!build_pass:cross_compile: {
        QMAKE_CFLAGS += -s WASM=1 -s \"BINARYEN_METHOD=\'native-wasm\'\" -s \"BINARYEN_TRAP_MODE=\'clamp\'\"
        QMAKE_CXXFLAGS += -s WASM=1 -s \"BINARYEN_METHOD=\'native-wasm\'\" -s \"BINARYEN_TRAP_MODE=\'clamp\'\"
        QMAKE_LFLAGS += -s WASM=1 -s \"BINARYEN_METHOD=\'native-wasm\'\" -s \"BINARYEN_TRAP_MODE=\'clamp\'\"
    }

    # Copy hosting html and javascript to the application build directory.
    exists($$[QT_INSTALL_PLUGINS]/platforms/html5_shell.html) {
        # dont pass this until it's installed somewhere
        # otherwise makespec test fails during qt configure
        HTML5_PLUGIN_PATH = $$[QT_INSTALL_PLUGINS]/platforms
    } else {
        ## internal build. not installed
        HTML5_PLUGIN_PATH = $$PWD/../../../src/plugins/platforms/html5
    }

    # Copy/Generate main .html file (e.g. myapp.html) from the html5_shell.html by
    # replacing the app name placeholder with the actual app name.
    apphtml.target = $$DESTDIR/$$TARGET_HTML
    apphtml.commands += sed -e s/APPNAME/$$TARGET_BASE/g $$quote($$HTML5_PLUGIN_PATH/html5_shell.html) > $$quote($$DESTDIR/$$TARGET_HTML) $$escape_expand(\\n\\t)

    # Copy qtloader.js
    appjs.target = $$DESTDIR/qtloader.js
    appjs.commands += $$QMAKE_COPY $$quote($$HTML5_PLUGIN_PATH/qtloader.js) $$quote($$DESTDIR) $$escape_expand(\\n\\t)

    # Copy qtlogo.svg
    qtlogo.target = $$DESTDIR/qtlogo.svg
    qtlogo.commands += $$QMAKE_COPY $$quote($$HTML5_PLUGIN_PATH/qtlogo.svg) $$quote($$DESTDIR) $$escape_expand(\\n\\t)

    QMAKE_EXTRA_TARGETS += apphtml appjs qtlogo
    POST_TARGETDEPS += $$apphtml.target $$appjs.target $$qtlogo.target

    # Add manual target to make "make -B shellfiles" work.
    shellfiles.target = shellfiles
    shellfiles.depends = $$apphtml.target $$appjs.target $$qtlogo.target
    QMAKE_EXTRA_TARGETS += shellfiles

    # emscripten ports are linked into the main module (this app), not the Qt
    # libs which reference them
    qt {
        qt_depends = $$resolve_depends(QT, "QT.")
        contains(qt_depends, core(-private)?): QMAKE_LFLAGS += \
            $$QMAKE_LIBS_THREAD $$QMAKE_LIBS_ZLIB
        contains(qt_depends, gui(-private)?): QMAKE_LFLAGS += \
            $$QMAKE_LIBS_FREETYPE $$QMAKE_LIBS_LIBPNG
    }
}

# Creates the stand-alone version of the library from bitcode
!static:contains(TEMPLATE, .*lib): {
    load(resolve_target)
    QMAKE_POST_LINK += $$QMAKE_LINK_SHLIB $$QMAKE_RESOLVED_TARGET -o $${QMAKE_RESOLVED_TARGET}.js

    QMAKE_INCDIR += $$(HOME)/.emscripten_ports/openssl/include

    !build_pass:cross_compile: {
        QMAKE_CFLAGS += -s WASM=1 -s \"BINARYEN_METHOD=\'native-wasm\'\"
        QMAKE_LFLAGS += -s WASM=1 -s \"BINARYEN_METHOD=\'native-wasm\'\"
        QMAKE_CXXFLAGS += -s WASM=1 -s \"BINARYEN_METHOD=\'native-wasm\'\"
    }
}
